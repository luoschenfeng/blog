# 浮点数

## 浮点数的表示

大多数语言的浮点数系统的设计遵循 `IEEE 754` 标准, 如果说 java 的浮点数是该标准的子集，那 javascript 就是该子集的子集。因为 javascript 只有一个 number 类型，类似于 java 的 double 类型，都是 IEEE 754 的双精度类型，是 64 位浮点数。

64位在内存中的储存顺序(从高位到低位)为： **符号位（S）** 占1位、**指数位(E)** 占11位 、**有效位(M)** 占52位三部分组成。如下图：


![浮点数图解](/images/number-64-bit.png)


数值的表示可以写成：$S * M * 2 ^ E$  (*符号位 1 表示 负数， 0 表示正数*)

:::tip
实际的应用中，很少会用到高精度数值，这种数字表示方式的痛点在于[**表示性错误**](#表示性错误)，所以一味的增加表示位数并不能解决问题
:::

:::tip
由于是二进制表示，所以有效数的范围为 $2^0 < w < 2^1$,也就是 0.5 < w < 1, 如果不在这个范围内则可以通过改变指数位来达到相同的效果
:::

:::details 以 0.34 为例 
我们以 3.4 为例来看一下其 浮点数表示

3.4 = $0.85 * 2 ^ 2$ 则可以看出 S 为 0 ，M 为 85(只存小数部分), E 为 2    

二进制表示为 '11.011001100110011001100110011001100110011001100110011'
:::
## 表示性错误

表示性错误 是指某些（其实是大多数）十进制小数无法以二进制（以 2 为基数的计数制）精确表示这一事实造成的错误。

:::tip
表示性错误 的根本原因是这个十进制数 不能被 $S * M * 2 ^ E$ 精确表示
:::

:::details 以 0.1 为例

$\frac{1} {10} ~= \frac {M} {2 ^ E}$

则 M 可以写成

$M ~= 2 ^ E * 10$

并且 M 恰好有 53 位 (即 >= $2 ^ {52}$ 但 < $2 ^ {53}$)

也就是说，56 是唯一的 E 值能令 M 恰好有 53 位。 这样 M 的最佳可能值就是经过舍入的商:

$M = Math.round(2^{56} / 10) = 7205759403792794$

则数字 0.1 可以表示为 $7205759403792794 / 2 ** 56$

分子和分母都除以二则结果小数为:

$3602879701896397 / 2 ^ {55}$

二进制表示为 '0.0001100110011001100110011001100110011001100110011001101'

请注意由于我们做了向上舍入，这个结果实际上略大于 1/10；如果我们没有向上舍入，则商将会略小于 1/10。 但无论如何它都不会是 精确的 1/10！

因此计算永远不会“看到”1/10：它实际看到的就是上面所给出的小数，它所能达到的最佳 754 双精度近似值:

```
0.1 * 2 ** 55
```

如果我们将该小数乘以 10**55，我们可以看到该值输出为 55 位的十进制数

```
3602879701896397 * 10 ** 55 // 2 ** 55 => 1000000000000000055511151231257827021181583404541015625

```

这意味着存储在计算机中的确切数值等于十进制数值 0.1000000000000000055511151231257827021181583404541015625。 许多语言都不会显示这个完整的十进制数值，而是将结果舍入为 17 位有效数字为 '0.10000000000000001'

:::



